package com.probielab.microiot.mq

import com.probielab.microiot.services.HardwareService
import com.probielab.microiot.utils.reactivex.log4vertx
import com.sun.istack.Nullable
import io.netty.handler.codec.mqtt.MqttFixedHeader
import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader
import io.netty.handler.codec.mqtt.MqttQoS
import io.vertx.core.AsyncResult
import io.vertx.core.Handler
import io.vertx.core.json.JsonObject
import io.vertx.mqtt.MqttClientOptions
import io.vertx.reactivex.core.AbstractVerticle
import io.vertx.reactivex.core.Future
import io.vertx.reactivex.core.Promise
import io.vertx.reactivex.core.buffer.Buffer
import io.vertx.reactivex.core.eventbus.EventBus
import io.vertx.reactivex.core.eventbus.Message
import io.vertx.reactivex.core.eventbus.MessageConsumer
import io.vertx.reactivex.mqtt.MqttClient
import io.vertx.reactivex.mqtt.messages.MqttConnAckMessage
import io.vertx.reactivex.mqtt.messages.MqttSubscribeMessage

class MqttVerticle : AbstractVerticle() {
  private var mqttConsumer: MessageConsumer<JsonObject>? = null
  private var mqttSubConsumer: MessageConsumer<JsonObject>? = null
  private var mqttClient: MqttClient? = null

  companion object {
    private const val MQTT_SERVER_HOST = "112.74.165.209"
    private const val MQTT_SERVER_PORT = 1885
    const val CONFIG_MICRO_IOT_MQTT_QUEUE = "microiot.mqtt.queue"
    const val CONFIG_MICRO_IOT_MQTT_SUB_QUEUE = "microiot.mqtt.sub.queue"
    var entries = JsonObject()
    private fun publishMessage(eb: EventBus, mqttClient: MqttClient, topic: String, message: String): Future<JsonObject> {
      val mqttResult = Promise.promise<JsonObject>()
      mqttClient.publish(topic, Buffer.buffer(message), MqttQoS.AT_MOST_ONCE, false, false)
      return mqttResult.future()
    }

    private fun publishMessage(mqttClient: MqttClient, topic: String, message: Int) {}
    private fun publishMessage(mqttClient: MqttClient, topic: String, message: Array<Byte>) {}
    private fun successHandler(promise: Promise<JsonObject>) {
      promise.complete(JsonObject().put("code", 0))
    }

    private fun errorHandler(promise: Promise<JsonObject>) {
      promise.complete(JsonObject().put("code", -1))
    }

    private fun errorHandler(promise: Promise<JsonObject>, @Nullable message: String, @Nullable throwable: Throwable?, @Nullable eb: EventBus) {
      promise.complete(JsonObject().put("code", -1))
      if (throwable != null) log4vertx.error(eb, "MQTT Send ERROR on event:$message", throwable)
    }

    init {
      entries.put("identifier", "MicroIoTData")
        .put("name", "Control")
        .put("desc", "Downlink")
        .put("type", "bool")
        .put("data", true)
    }
  }

  override fun start() {
    val mqttClientOptions = MqttClientOptions()
    val eb = vertx.eventBus()
    mqttClientOptions
      .setWillQoS(0)
      .setUsername("guest")
      .setPassword("guest")
      .setAutoKeepAlive(true).isAutoGeneratedClientId = true
    mqttClient = MqttClient.create(vertx, mqttClientOptions)

    mqttClient?.connect(MQTT_SERVER_PORT, MQTT_SERVER_HOST) { res: AsyncResult<MqttConnAckMessage?> ->
      if (res.succeeded()) {
        mqttClient!!
          .publishHandler { MqttRouter.mqttEventSwitcher(it, vertx) }
          .subscribe("#", 0)
          .pingResponseHandler {
            //删除测试代码
          }
        log4vertx.info(eb, "MQTT connected! Host" + MQTT_SERVER_HOST + " Port:" + MQTT_SERVER_PORT + " ClientId:" + mqttClientOptions.clientId)
      } else {
        log4vertx.error(eb, "MQTT connect failed! Host" + MQTT_SERVER_HOST + " Port:" + MQTT_SERVER_PORT + " ClientId:" + mqttClientOptions.clientId, res.cause())
      }
    }
    mqttConsumer = eb.consumer(CONFIG_MICRO_IOT_MQTT_QUEUE)
    mqttSubConsumer = eb.consumer(CONFIG_MICRO_IOT_MQTT_SUB_QUEUE)
    mqttConsumer?.completionHandler { res: AsyncResult<Void?> ->
      if (res.succeeded()) {
        log4vertx.info(eb, "MQTT ready")
      } else {
        log4vertx.error(eb, "MQTT Consume error", res.cause())
      }
    }
    mqttSubConsumer?.completionHandler { res: AsyncResult<Void?> ->
      if (res.succeeded()) {
        log4vertx.info(eb, "MQTT Sub Server Ready")
      } else {
        log4vertx.error(eb, "MQTT Sub Server Error", res.cause())
      }
    }

    mqttConsumer?.handler(Handler { res: Message<JsonObject> ->
      if (!mqttClient!!.isConnected) {
        res.reply(JsonObject().put("result", "Mqtt server unconnected!"))
      } else {
        val mqttRequest = res.body()
        publishMessage(eb, mqttClient!!, mqttRequest.getString("topic"), mqttRequest.getString("message"))
          .setHandler { publishRes: AsyncResult<JsonObject> ->
            if (publishRes.succeeded()) {
              res.reply(publishRes.result())
            } else {
              res.reply("Unknown ERROR")
            }
          }
      }
    })

    mqttSubConsumer?.handler() { res: Message<JsonObject> ->
      if (!mqttClient!!.isConnected) {
        res.reply(JsonObject().put("result", "Mqtt server unconnected!"))
      } else {
        val mqttSubRequest = res.body()

      }
    }
  }
}
