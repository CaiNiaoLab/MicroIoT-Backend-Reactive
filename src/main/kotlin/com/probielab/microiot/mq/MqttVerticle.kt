package com.probielab.microiot.mq

import com.probielab.microiot.utils.reactivex.log4vertx
import com.sun.istack.Nullable
import io.netty.handler.codec.mqtt.MqttQoS
import io.vertx.core.AsyncResult
import io.vertx.core.Handler
import io.vertx.core.json.JsonObject
import io.vertx.mqtt.MqttClientOptions
import io.vertx.reactivex.core.AbstractVerticle
import io.vertx.reactivex.core.Future
import io.vertx.reactivex.core.Promise
import io.vertx.reactivex.core.buffer.Buffer
import io.vertx.reactivex.core.eventbus.EventBus
import io.vertx.reactivex.core.eventbus.Message
import io.vertx.reactivex.core.eventbus.MessageConsumer
import io.vertx.reactivex.mqtt.MqttClient
import io.vertx.reactivex.mqtt.messages.MqttConnAckMessage

class MqttVerticle : AbstractVerticle() {
  var mqttConsumer: MessageConsumer<JsonObject>? = null
  var mqttSubConsumer: MessageConsumer<JsonObject>? = null

  companion object {
    private const val MQTT_SERVER_HOST = "112.74.165.209"
    private const val MQTT_SERVER_PORT = 1883
    const val CONFIG_MICRO_IOT_MQTT_QUEUE = "microiot.mqtt.queue"
    const val CONFIG_MICRO_IOT_MQTT_SUB_QUEUE = "microiot.mqtt.sub.queue"
    var entries = JsonObject()
    private fun publishMessage(eb: EventBus, mqttClient: MqttClient, topic: String, message: String): Future<JsonObject> {
      val mqttResult = Promise.promise<JsonObject>()
      mqttClient.publish(topic, Buffer.buffer(message), MqttQoS.AT_MOST_ONCE, false, false)
      return mqttResult.future()
    }

    private fun publishMessage(mqttClient: MqttClient, topic: String, message: Int) {}
    private fun publishMessage(mqttClient: MqttClient, topic: String, message: Array<Byte>) {}
    private fun successHandler(promise: Promise<JsonObject>) {
      promise.complete(JsonObject().put("code", 0))
    }

    private fun errorHandler(promise: Promise<JsonObject>) {
      promise.complete(JsonObject().put("code", -1))
    }

    private fun errorHandler(promise: Promise<JsonObject>, @Nullable message: String, @Nullable throwable: Throwable?, @Nullable eb: EventBus) {
      promise.complete(JsonObject().put("code", -1))
      if (throwable != null) log4vertx.error(eb, "MQTT Send ERROR on event:$message", throwable)
    }

    init {
      entries.put("identifier", "MicroIoTData")
        .put("name", "Control")
        .put("desc", "Downlink")
        .put("type", "bool")
        .put("data", "0")
    }
  }

  override fun start() {
    val mqttClientOptions = MqttClientOptions()
    mqttClientOptions
      .setWillQoS(0)
      .setAutoGeneratedClientId(false).clientId = "Vert.x.mqtt.client"
    val mqttClient = MqttClient.create(vertx, mqttClientOptions)
    val eb = vertx.eventBus()
    mqttConsumer = eb.consumer(CONFIG_MICRO_IOT_MQTT_QUEUE)
    mqttSubConsumer = eb.consumer(CONFIG_MICRO_IOT_MQTT_SUB_QUEUE)
    mqttConsumer?.completionHandler { res: AsyncResult<Void?> ->
      if (res.succeeded()) {
        log4vertx.info(eb, "MQTT ready")
      } else {
        log4vertx.error(eb, "MQTT Consume error", res.cause())
      }
    }
    mqttSubConsumer?.completionHandler { res: AsyncResult<Void?> ->
      if (res.succeeded()) {
        log4vertx.info(eb, "MQTT Sub Server Ready")
      } else {
        log4vertx.error(eb, "MQTT Sub Server Error", res.cause())
      }
    }

    mqttConsumer?.handler(Handler { res: Message<JsonObject> ->
      if (!mqttClient.isConnected) {
        res.reply(JsonObject().put("result", "Mqtt server unconnected!"))
      } else {
        val mqttRequest = res.body()
        publishMessage(eb, mqttClient, mqttRequest.getString("topic"), mqttRequest.getString("message"))
          .setHandler { publishRes: AsyncResult<JsonObject> ->
            if (publishRes.succeeded()) {
              res.reply(publishRes.result())
            } else {
              res.reply("Unknown ERROR")
            }
          }
      }
    })

    mqttSubConsumer?.handler() { res: Message<JsonObject> ->
      if (!mqttClient.isConnected) {
        res.reply(JsonObject().put("result", "Mqtt server unconnected!"))
      } else {
        val mqttRequest = res.body()
        publishMessage(eb, mqttClient, mqttRequest.getString("topic"), mqttRequest.getString("message"))
          .setHandler { publishRes: AsyncResult<JsonObject> ->
            if (publishRes.succeeded()) {
              res.reply(publishRes.result())
            } else {
              res.reply("Unknown ERROR")
            }
          }
      }
    }

    mqttClient.connect(MQTT_SERVER_PORT, MQTT_SERVER_HOST) { res: AsyncResult<MqttConnAckMessage?> ->
      if (res.succeeded()) {
        log4vertx.info(eb, "MQTT connected! Host" + MQTT_SERVER_HOST + " Port:" + MQTT_SERVER_PORT + " ClientId:" + mqttClientOptions.clientId)
      } else {
        log4vertx.error(eb, "MQTT connect failed! Host" + MQTT_SERVER_HOST + " Port:" + MQTT_SERVER_PORT + " ClientId:" + mqttClientOptions.clientId, res.cause())
      }
    }
  }
}
